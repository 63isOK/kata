# hit 3

从一个数组中取3个数,条件是3个数的和为0.约束:3个数的序列不能重复.

eg: 1 1 2 -1 -1 0, 输出是`[-1,0,1],[-1,-1,2]`

## 暴力求解法

利用3层循环实现.

- 时间复杂度 O(n3)
- 空间复杂度,除了最终存储结果空间,额外用到的是固定数量的局部变量,复杂度是O(1)

## 问题转换 - hit2

和hit2不一样的是:

- hit3的解空间关心值,不关心索引
- hit2只有唯一解,hit3可能有多个解,或无解

如果基于hit2来改造:

- hash表存的值已经是次数,不是索引
- 分两次循环
  - 第一次的循环是构建hash表
  - 第二次循环是二层循环,第一层是将hit3降为hit2,第二层是找剩下两个数

`go test -v -bench . -cpuprofile cpu.prof`,`go tool pprof -http=:9999 cpu.prof `
可以分析cpu性能,单词执行测试时间太短,用bench测试,可以看出fmt.Sprintf消耗了70%的性能,
这点可以重点优化.

这个算法只是将复杂度降为了O(n*n).

## 排序之后,用两个游标来找值

考虑到重复元素,两个游标移动步长可以优化,但语言本身对数组的遍历有优化,
具体的对比需要后续进一步分析.

虽然在开头有个排序,但总比上一种方法的字符串拼接剩了不少cpu消耗.